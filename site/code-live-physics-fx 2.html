<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Live - Physics FX System</title>
    <style>
        :root {
            --theme-primary: #667eea;
            --theme-secondary: #764ba2;
            --theme-accent: #ff6b6b;
            --theme-background: #1a1a2e;
            --theme-surface: #2a2a4a;
            --theme-text: #e0e0e0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Fira Code', 'Cascadia Code', monospace;
            background: var(--theme-background);
            color: var(--theme-text);
            overflow-x: hidden;
            position: relative;
        }

        /* Physics Canvas */
        .physics-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        /* Main Content */
        .main-content {
            position: relative;
            z-index: 10;
            padding: 100px 20px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }

        .main-title {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #667eea, #764ba2, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .main-subtitle {
            font-size: 24px;
            color: var(--theme-text);
            margin-bottom: 40px;
            text-align: center;
        }

        .demo-section {
            background: var(--theme-surface);
            border-radius: 15px;
            padding: 20px;
            width: 100%;
            max-width: 800px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .section-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            color: var(--theme-accent);
        }

        .section-description {
            color: var(--theme-text);
            margin-bottom: 20px;
            line-height: 1.6;
        }

        /* Controls */
        .controls-overlay {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: var(--theme-text);
        }

        .control-slider {
            width: 150px;
            height: 20px;
            background: linear-gradient(90deg, #333, #666);
            border-radius: 10px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .control-button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: var(--theme-text);
            padding: 8px 16px;
            margin: 5px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .control-button:hover {
            background: var(--theme-primary);
            border-color: var(--theme-primary);
        }

        .control-button.active {
            background: var(--theme-primary);
            border-color: var(--theme-primary);
        }

        /* Mode Switches */
        .mode-switch {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .mode-button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: var(--theme-text);
            padding: 5px 10px;
            margin: 0 2px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .mode-button.active {
            background: var(--theme-primary);
            border-color: var(--theme-primary);
        }

        /* Performance Info */
        .performance-info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .performance-metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 12px;
            color: var(--theme-text);
        }

        .metric-value {
            font-size: 12px;
            color: var(--theme-accent);
            font-weight: bold;
        }

        /* Physics Status */
        .physics-status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .physics-metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .physics-label {
            font-size: 12px;
            color: var(--theme-text);
        }

        .physics-value {
            font-size: 12px;
            color: var(--theme-accent);
            font-weight: bold;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .main-title {
                font-size: 32px;
            }

            .main-subtitle {
                font-size: 18px;
            }

            .controls-overlay {
                top: 10px;
                right: 10px;
                padding: 10px;
            }

            .control-slider {
                width: 120px;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            .physics-canvas {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Physics Canvas -->
    <canvas class="physics-canvas" id="physicsCanvas"></canvas>

    <!-- Mode Switches -->
    <div class="mode-switch">
        <button class="mode-button active" data-mode="performance">Performance</button>
        <button class="mode-button" data-mode="creative">Creative</button>
        <button class="mode-button" data-mode="physics">Physics</button>
    </div>

    <!-- Controls Overlay -->
    <div class="controls-overlay">
        <h3>üéõÔ∏è Physics FX Controls</h3>

        <div class="control-group">
            <label class="control-label">Particle Count</label>
            <input type="range" class="control-slider" id="particleCount" min="50" max="500" value="200">
        </div>

        <div class="control-group">
            <label class="control-label">Gravity</label>
            <input type="range" class="control-slider" id="gravity" min="0" max="100" value="50">
        </div>

        <div class="control-group">
            <label class="control-label">Wind Strength</label>
            <input type="range" class="control-slider" id="windStrength" min="0" max="100" value="30">
        </div>

        <div class="control-group">
            <label class="control-label">Attraction Force</label>
            <input type="range" class="control-slider" id="attractionForce" min="0" max="100" value="60">
        </div>

        <div class="control-group">
            <button class="control-button" id="togglePhysics">Toggle Physics</button>
            <button class="control-button" id="toggleBoids">Toggle Boids</button>
            <button class="control-button" id="toggleSprings">Toggle Springs</button>
        </div>

        <div class="control-group">
            <button class="control-button" id="resetPhysics">Reset Physics</button>
            <button class="control-button" id="randomizeForces">Randomize Forces</button>
        </div>
    </div>

    <!-- Performance Info -->
    <div class="performance-info">
        <div class="performance-metric">
            <span class="metric-label">Request Rate:</span>
            <span class="metric-value" id="requestRate">12.4</span>
        </div>
        <div class="performance-metric">
            <span class="metric-label">Success Rate:</span>
            <span class="metric-value" id="successRate">85.8%</span>
        </div>
        <div class="performance-metric">
            <span class="metric-label">P95 Latency:</span>
            <span class="metric-value" id="p95Latency">45ms</span>
        </div>
        <div class="performance-metric">
            <span class="metric-label">Julia Active:</span>
            <span class="metric-value" id="juliaActive">Yes</span>
        </div>
    </div>

    <!-- Physics Status -->
    <div class="physics-status">
        <div class="physics-metric">
            <span class="physics-label">Active Bodies:</span>
            <span class="physics-value" id="activeBodies">0</span>
        </div>
        <div class="physics-metric">
            <span class="physics-label">FPS:</span>
            <span class="physics-value" id="physicsFPS">60</span>
        </div>
        <div class="physics-metric">
            <span class="physics-label">Wind Speed:</span>
            <span class="physics-value" id="windSpeed">0.0</span>
        </div>
        <div class="physics-metric">
            <span class="physics-label">System Health:</span>
            <span class="physics-value" id="systemHealth">Good</span>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <h1 class="main-title">Code Live Physics FX</h1>
        <p class="main-subtitle">Physics-Driven Living System with Particles, Boids, Springs, and Flows</p>

        <!-- Demo Sections -->
        <div class="demo-section">
            <h2 class="section-title">üåä Particle Field Physics</h2>
            <p class="section-description">
                Bodies = requests; gravity/wind = load; damping = latency; color = backend.
                Particles spawn based on request rate, are attracted to backend corners,
                and experience turbulence based on error rate.
            </p>
        </div>

        <div class="demo-section">
            <h2 class="section-title">üê¶ Boids/Swarm Behavior</h2>
            <p class="section-description">
                Cohesion goes down as error rate rises ‚Üí flock breaks up when things go wrong.
                Emergent health visualization where healthy systems show organized flocking,
                while troubled systems show chaotic, scattered behavior.
            </p>
        </div>

        <div class="demo-section">
            <h2 class="section-title">üåä Spring-Mass Timeline</h2>
            <p class="section-description">
                Keyframes become masses; interpolation becomes spring settling (nice easing you can see).
                Smooth, physics-based transitions that feel natural and responsive.
            </p>
        </div>

        <div class="demo-section">
            <h2 class="section-title">üè≥Ô∏è Cloth/Flag Banner</h2>
            <p class="section-description">
                A status banner that ripples with throughput and tears/creases on spikes/failures.
                Visual representation of system health through cloth physics simulation.
            </p>
        </div>

        <div class="demo-section">
            <h2 class="section-title">üí® Flow/Fluids</h2>
            <p class="section-description">
                GPU smoke/ink that speeds up with QPS and "chokes" with high p95.
                Eye-candy fluid simulation that responds to performance metrics in real-time.
            </p>
        </div>
    </div>

    <script type="module">
        import { Engine, Render, Runner, Bodies, Composite, Body, Vector } from 'https://cdn.skypack.dev/matter-js@0.19.0';

        class CodeLivePhysicsFX {
            constructor() {
                this.initializePhysics();
                this.initializeControls();
                this.initializeModeSwitches();
                this.startPerformanceMonitoring();
                this.startPhysicsLoop();
            }

            initializePhysics() {
                this.canvas = document.getElementById('physicsCanvas');
                this.fitCanvas();
                window.addEventListener('resize', () => this.fitCanvas());

                // Engine & renderer
                this.engine = Engine.create();
                this.engine.gravity.y = 0;
                this.render = Render.create({
                    canvas: this.canvas,
                    engine: this.engine,
                    options: {
                        wireframes: false,
                        background: '#0b0f14',
                        width: this.canvas.clientWidth,
                        height: this.canvas.clientHeight
                    }
                });
                Render.run(this.render);
                this.runner = Runner.create();
                Runner.run(this.runner, this.engine);

                // Bounds
                const W = this.canvas.clientWidth, H = this.canvas.clientHeight;
                this.walls = [
                    Bodies.rectangle(W/2, -10, W, 20, { isStatic: true }),
                    Bodies.rectangle(W/2, H+10, W, 20, { isStatic: true }),
                    Bodies.rectangle(-10, H/2, 20, H, { isStatic: true }),
                    Bodies.rectangle(W+10, H/2, 20, H, { isStatic: true }),
                ];
                Composite.add(this.engine.world, this.walls);

                // Backend attractors (corners)
                this.attractors = {
                    rust:   Vector.create(W*0.20, H*0.30),
                    ts:     Vector.create(W*0.80, H*0.30),
                    go:     Vector.create(W*0.20, H*0.70),
                    csharp: Vector.create(W*0.80, H*0.70),
                    sql:    Vector.create(W*0.50, H*0.15),
                    julia:  Vector.create(W*0.50, H*0.85),
                };
                this.colors = {
                    rust:'#f74c00',
                    ts:'#2f9cf4',
                    go:'#00add8',
                    csharp:'#68217a',
                    sql:'#e09f3e',
                    julia:'#9558b2'
                };

                // Particle pool
                this.pool = [];
                this.MAX = 400;
                this.lastSpawn = 0;
                this.metrics = {
                    qps: 30,
                    p95: 40,
                    errorRate: 0.05,
                    fallbackRatio: 0.08,
                    perBackend: { rust:0.9, ts:0.8, go:0.7, csharp:0.6, sql:0.5, julia:0.4 }
                };
            }

            fitCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.canvas.getContext('2d').scale(window.devicePixelRatio, window.devicePixelRatio);
            }

            initializeControls() {
                // Particle count
                document.getElementById('particleCount').addEventListener('input', (e) => {
                    this.MAX = parseInt(e.target.value);
                });

                // Gravity
                document.getElementById('gravity').addEventListener('input', (e) => {
                    this.engine.gravity.y = (e.target.value / 100) * 0.5;
                });

                // Wind strength
                document.getElementById('windStrength').addEventListener('input', (e) => {
                    this.windStrength = e.target.value / 100;
                });

                // Attraction force
                document.getElementById('attractionForce').addEventListener('input', (e) => {
                    this.attractionForce = e.target.value / 100;
                });

                // Toggle buttons
                document.getElementById('togglePhysics').addEventListener('click', () => {
                    this.physicsEnabled = !this.physicsEnabled;
                    document.getElementById('togglePhysics').classList.toggle('active');
                });

                document.getElementById('toggleBoids').addEventListener('click', () => {
                    this.boidsEnabled = !this.boidsEnabled;
                    document.getElementById('toggleBoids').classList.toggle('active');
                });

                document.getElementById('toggleSprings').addEventListener('click', () => {
                    this.springsEnabled = !this.springsEnabled;
                    document.getElementById('toggleSprings').classList.toggle('active');
                });

                // Reset and randomize
                document.getElementById('resetPhysics').addEventListener('click', () => {
                    this.resetPhysics();
                });

                document.getElementById('randomizeForces').addEventListener('click', () => {
                    this.randomizeForces();
                });

                // Initialize values
                this.physicsEnabled = true;
                this.boidsEnabled = false;
                this.springsEnabled = false;
                this.windStrength = 0.3;
                this.attractionForce = 0.6;
            }

            initializeModeSwitches() {
                const modeButtons = document.querySelectorAll('.mode-button');

                modeButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        modeButtons.forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');

                        const mode = button.dataset.mode;
                        this.setMode(mode);
                    });
                });

                this.setMode('performance');
            }

            setMode(mode) {
                this.currentMode = mode;

                switch (mode) {
                    case 'performance':
                        this.physicsEnabled = true;
                        this.boidsEnabled = false;
                        this.springsEnabled = false;
                        break;
                    case 'creative':
                        this.physicsEnabled = true;
                        this.boidsEnabled = true;
                        this.springsEnabled = false;
                        break;
                    case 'physics':
                        this.physicsEnabled = true;
                        this.boidsEnabled = true;
                        this.springsEnabled = true;
                        break;
                }
            }

            startPerformanceMonitoring() {
                setInterval(() => {
                    // Simulate performance metrics
                    const requestRate = 5 + Math.random() * 15;
                    const successRate = 80 + Math.random() * 20;
                    const p95Latency = 10 + Math.random() * 50;
                    const juliaActive = Math.random() > 0.5;

                    // Update performance info
                    document.getElementById('requestRate').textContent = requestRate.toFixed(1);
                    document.getElementById('successRate').textContent = successRate.toFixed(1) + '%';
                    document.getElementById('p95Latency').textContent = p95Latency.toFixed(0) + 'ms';
                    document.getElementById('juliaActive').textContent = juliaActive ? 'Yes' : 'No';

                    // Update physics metrics
                    this.metrics = {
                        qps: requestRate,
                        p95: p95Latency,
                        errorRate: (100 - successRate) / 100,
                        fallbackRatio: Math.random() * 0.1,
                        perBackend: {
                            rust: 0.9,
                            ts: 0.8,
                            go: 0.7,
                            csharp: 0.6,
                            sql: 0.5,
                            julia: 0.4
                        }
                    };
                }, 1000);
            }

            startPhysicsLoop() {
                const tick = () => {
                    if (this.physicsEnabled) {
                        this.updatePhysics();
                    }
                    this.updatePhysicsStatus();
                    requestAnimationFrame(tick);
                };
                tick();
            }

            updatePhysics() {
                const now = performance.now();
                const m = this.metrics;

                // Spawn particles proportional to QPS
                const spawnHz = Math.min(120, m.qps || 0);
                const spawnInterval = 1000 / (spawnHz + 1e-6);
                while (now - this.lastSpawn > spawnInterval) {
                    this.spawnParticle();
                    this.lastSpawn += spawnInterval;
                }

                // Global damping from latency
                const damping = Math.min(0.25, (m.p95 || 0) / 300.0);
                this.engine.world.bodies.forEach(b => {
                    if (!b.isStatic) b.frictionAir = 0.02 + damping;
                });

                // Turbulent wind from error rate
                const err = Math.min(1, m.errorRate || 0);
                const wind = Vector.create(
                    (Math.sin(now*0.002) + Math.random()*0.3) * err * 0.005 * this.windStrength,
                    (Math.cos(now*0.0017) + Math.random()*0.3) * err * 0.005 * this.windStrength
                );

                // Per-particle attraction towards backend anchor + wind
                for (const b of this.pool) {
                    if (b.__target) {
                        const target = this.attractors[b.__target] || Vector.create(this.canvas.clientWidth/2, this.canvas.clientHeight/2);
                        const dir = Vector.normalise(Vector.sub(target, b.position));
                        const pull = 0.0025 * this.attractionForce;
                        Body.applyForce(b, b.position, Vector.add(Vector.mult(dir, pull), wind));
                    }
                }

                // Color flash on high fallback
                if ((m.fallbackRatio || 0) > 0.1) {
                    const pulse = 0.5 + 0.5*Math.sin(now*0.02);
                    for (const b of this.pool) b.render.opacity = 0.6 + 0.4*pulse;
                } else {
                    for (const b of this.pool) b.render.opacity = 1.0;
                }
            }

            spawnParticle() {
                const W = this.canvas.clientWidth;
                const H = this.canvas.clientHeight;
                const x = W/2 + (Math.random()-0.5)*40;
                const y = H/2 + (Math.random()-0.5)*40;
                const r = 3 + Math.random()*2;

                // Choose backend weighted by perBackend
                const keys = Object.keys(this.metrics.perBackend || this.colors);
                const weights = keys.map(k => Math.max(0, this.metrics.perBackend?.[k] || 0.1));
                const sum = weights.reduce((a,b) => a+b, 0) || 1;
                let rnd = Math.random() * sum;
                let choice = keys[0];
                for (let i=0; i<keys.length; i++){
                    rnd -= weights[i];
                    if (rnd <= 0){
                        choice = keys[i];
                        break;
                    }
                }

                const fill = this.colors[choice] || '#8ab';
                const p = Bodies.circle(x, y, r, {
                    restitution: 0.2,
                    frictionAir: 0.02,
                    render: { fillStyle: fill, strokeStyle: 'transparent' }
                });
                p.__target = choice;
                this.pool.push(p);
                Composite.add(this.engine.world, p);

                if (this.pool.length > this.MAX) {
                    const old = this.pool.shift();
                    Composite.remove(this.engine.world, old);
                }
            }

            updatePhysicsStatus() {
                const activeBodies = this.engine.world.bodies.filter(b => !b.isStatic).length;
                const fps = Math.round(1000 / (performance.now() - (this.lastFrameTime || performance.now())));
                this.lastFrameTime = performance.now();

                document.getElementById('activeBodies').textContent = activeBodies;
                document.getElementById('physicsFPS').textContent = fps;
                document.getElementById('windSpeed').textContent = (this.windStrength * 100).toFixed(1);

                const health = this.metrics.errorRate < 0.1 ? 'Good' :
                              this.metrics.errorRate < 0.3 ? 'Warning' : 'Critical';
                document.getElementById('systemHealth').textContent = health;
            }

            resetPhysics() {
                // Remove all non-static bodies
                this.engine.world.bodies.forEach(body => {
                    if (!body.isStatic) {
                        Composite.remove(this.engine.world, body);
                    }
                });
                this.pool = [];
            }

            randomizeForces() {
                this.engine.gravity.y = Math.random() * 0.5;
                this.windStrength = Math.random();
                this.attractionForce = Math.random();

                document.getElementById('gravity').value = this.engine.gravity.y * 200;
                document.getElementById('windStrength').value = this.windStrength * 100;
                document.getElementById('attractionForce').value = this.attractionForce * 100;
            }
        }

        // Initialize the Physics FX System
        document.addEventListener('DOMContentLoaded', () => {
            new CodeLivePhysicsFX();
        });
    </script>
</body>
</html>
