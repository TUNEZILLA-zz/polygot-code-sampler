<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PCS Benchmarks - Polyglot Code Sampler Performance Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/index.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 20px;
      background: #f8f9fa;
      margin: 0;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 30px;
    }
    h1 {
      color: #2c3e50;
      margin-bottom: 10px;
      font-size: 2.5em;
    }
    .subtitle {
      color: #7f8c8d;
      margin-bottom: 30px;
      font-size: 1.1em;
    }
    .summary {
      background: #ecf0f1;
      padding: 20px;
      border-radius: 6px;
      margin-bottom: 30px;
    }
    .summary h3 {
      margin-top: 0;
      color: #2c3e50;
    }
    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    .summary-item {
      background: white;
      padding: 15px;
      border-radius: 4px;
      border-left: 4px solid #3498db;
    }
    .summary-item h4 {
      margin: 0 0 5px 0;
      color: #2c3e50;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .summary-item p {
      margin: 0;
      font-size: 1.2em;
      font-weight: bold;
      color: #34495e;
    }
    .controls {
      margin-bottom: 30px;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      align-items: center;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .control-group label {
      font-size: 0.9em;
      font-weight: 500;
      color: #2c3e50;
    }
    .control-group select {
      padding: 8px 12px;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      background: white;
      font-size: 0.9em;
    }
    .charts {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 30px;
      margin-bottom: 30px;
    }
    .chart-container {
      background: white;
      padding: 20px;
      border-radius: 6px;
      border: 1px solid #ecf0f1;
    }
    .chart-container h3 {
      margin-top: 0;
      color: #2c3e50;
      font-size: 1.2em;
    }
    .chart-container canvas {
      max-width: 100%;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #7f8c8d;
    }
    .error {
      background: #e74c3c;
      color: white;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 20px;
    }
    .last-updated {
      text-align: center;
      color: #95a5a6;
      font-size: 0.9em;
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #ecf0f1;
    }
    @media (max-width: 768px) {
      .container {
        padding: 15px;
      }
      .charts {
        grid-template-columns: 1fr;
      }
      .controls {
        flex-direction: column;
        align-items: stretch;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üöÄ PCS Benchmarks</h1>
    <p class="subtitle">Polyglot Code Sampler Performance Dashboard - Comparing backends over time (lower is better)</p>
    
    <div id="loading" class="loading">
      <p>üìä Loading benchmark data...</p>
    </div>
    
    <div id="error" class="error" style="display: none;">
      <p>‚ùå Error loading benchmark data. Please check the console for details.</p>
    </div>
    
    <div id="content" style="display: none;">
      <div class="summary">
        <h3>üìà Summary</h3>
        <div class="summary-grid" id="summary-grid">
          <!-- Summary items will be populated by JavaScript -->
        </div>
      </div>
      
      <div class="controls">
        <div class="control-group">
          <label for="test-select">Test Case:</label>
          <select id="test-select">
            <!-- Options will be populated by JavaScript -->
          </select>
        </div>
        <div class="control-group">
          <label for="backend-select">Backend:</label>
          <select id="backend-select">
            <!-- Options will be populated by JavaScript -->
          </select>
        </div>
        <div class="control-group">
          <label for="mode-select">Mode:</label>
          <select id="mode-select">
            <!-- Options will be populated by JavaScript -->
          </select>
        </div>
      </div>
      
      <div class="charts">
        <div class="chart-container">
          <h3>Performance by Backend</h3>
          <canvas id="chartByBackend"></canvas>
        </div>
        <div class="chart-container">
          <h3>Performance by Mode</h3>
          <canvas id="chartByMode"></canvas>
        </div>
        <div class="chart-container">
          <h3>Parallel vs Sequential</h3>
          <canvas id="chartParallel"></canvas>
        </div>
        <div class="chart-container">
          <h3>Performance Trends</h3>
          <canvas id="chartTrends"></canvas>
        </div>
      </div>
      
      <div class="last-updated" id="last-updated">
        <!-- Last updated time will be populated by JavaScript -->
      </div>
    </div>
  </div>

  <script>
    let benchmarkData = null;
    let charts = {};

    async function loadData() {
      try {
        const response = await fetch('benchmarks.json');
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        benchmarkData = await response.json();
        
        document.getElementById('loading').style.display = 'none';
        document.getElementById('content').style.display = 'block';
        
        initializeDashboard();
      } catch (error) {
        console.error('Error loading benchmark data:', error);
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'block';
      }
    }

    function initializeDashboard() {
      const { summary, results } = benchmarkData;
      
      // Update summary
      updateSummary(summary);
      
      // Populate controls
      populateControls(results);
      
      // Create charts
      createCharts(results);
      
      // Update last updated time
      document.getElementById('last-updated').textContent = 
        `Last updated: ${new Date(summary.last_updated).toLocaleString()}`;
    }

    function updateSummary(summary) {
      const grid = document.getElementById('summary-grid');
      grid.innerHTML = `
        <div class="summary-item">
          <h4>Total Results</h4>
          <p>${summary.total_results.toLocaleString()}</p>
        </div>
        <div class="summary-item">
          <h4>Backends</h4>
          <p>${summary.backends.length}</p>
        </div>
        <div class="summary-item">
          <h4>Test Cases</h4>
          <p>${summary.tests.length}</p>
        </div>
        <div class="summary-item">
          <h4>Date Range</h4>
          <p>${summary.date_range.start} to ${summary.date_range.end}</p>
        </div>
      `;
    }

    function populateControls(results) {
      const tests = [...new Set(results.map(r => r.test))].sort();
      const backends = [...new Set(results.map(r => r.backend))].sort();
      const modes = [...new Set(results.map(r => r.mode))].sort();

      // Populate test select
      const testSelect = document.getElementById('test-select');
      testSelect.innerHTML = tests.map(test => 
        `<option value="${test}">${test}</option>`
      ).join('');

      // Populate backend select
      const backendSelect = document.getElementById('backend-select');
      backendSelect.innerHTML = backends.map(backend => 
        `<option value="${backend}">${backend}</option>`
      ).join('');

      // Populate mode select
      const modeSelect = document.getElementById('mode-select');
      modeSelect.innerHTML = modes.map(mode => 
        `<option value="${mode}">${mode}</option>`
      ).join('');

      // Add event listeners
      [testSelect, backendSelect, modeSelect].forEach(select => {
        select.addEventListener('change', () => updateCharts());
      });
    }

    function createCharts(results) {
      // Chart 1: Performance by Backend
      createBackendChart(results);
      
      // Chart 2: Performance by Mode
      createModeChart(results);
      
      // Chart 3: Parallel vs Sequential
      createParallelChart(results);
      
      // Chart 4: Performance Trends
      createTrendsChart(results);
    }

    function createBackendChart(results) {
      const ctx = document.getElementById('chartByBackend').getContext('2d');
      
      if (charts.backend) {
        charts.backend.destroy();
      }

      const test = document.getElementById('test-select').value;
      const filteredResults = results.filter(r => r.test === test);
      
      const dates = [...new Set(filteredResults.map(r => r.timestamp.split('T')[0]))].sort();
      const backends = [...new Set(filteredResults.map(r => r.backend))];

      const datasets = backends.map(backend => {
        const data = dates.map(date => {
          const dayResults = filteredResults.filter(r => 
            r.backend === backend && r.timestamp.startsWith(date)
          );
          if (dayResults.length === 0) return null;
          return Math.min(...dayResults.map(r => r.mean_ns));
        });

        return {
          label: backend,
          data: data,
          borderColor: getColor(backend),
          backgroundColor: getColor(backend, 0.1),
          tension: 0.1,
          fill: false
        };
      });

      charts.backend = new Chart(ctx, {
        type: 'line',
        data: { labels: dates, datasets },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: `${test}: Performance by Backend` },
            legend: { position: 'top' }
          },
          scales: {
            y: {
              type: 'logarithmic',
              title: { display: true, text: 'Nanoseconds (log scale)' }
            }
          }
        }
      });
    }

    function createModeChart(results) {
      const ctx = document.getElementById('chartByMode').getContext('2d');
      
      if (charts.mode) {
        charts.mode.destroy();
      }

      const backend = document.getElementById('backend-select').value;
      const test = document.getElementById('test-select').value;
      const filteredResults = results.filter(r => 
        r.backend === backend && r.test === test
      );
      
      const dates = [...new Set(filteredResults.map(r => r.timestamp.split('T')[0]))].sort();
      const modes = [...new Set(filteredResults.map(r => r.mode))];

      const datasets = modes.map(mode => {
        const data = dates.map(date => {
          const dayResults = filteredResults.filter(r => 
            r.mode === mode && r.timestamp.startsWith(date)
          );
          if (dayResults.length === 0) return null;
          return Math.min(...dayResults.map(r => r.mean_ns));
        });

        return {
          label: mode,
          data: data,
          borderColor: getColor(mode),
          backgroundColor: getColor(mode, 0.1),
          tension: 0.1,
          fill: false
        };
      });

      charts.mode = new Chart(ctx, {
        type: 'line',
        data: { labels: dates, datasets },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: `${backend}: ${test} by Mode` },
            legend: { position: 'top' }
          },
          scales: {
            y: {
              type: 'logarithmic',
              title: { display: true, text: 'Nanoseconds (log scale)' }
            }
          }
        }
      });
    }

    function createParallelChart(results) {
      const ctx = document.getElementById('chartParallel').getContext('2d');
      
      if (charts.parallel) {
        charts.parallel.destroy();
      }

      const test = document.getElementById('test-select').value;
      const filteredResults = results.filter(r => r.test === test);
      
      const dates = [...new Set(filteredResults.map(r => r.timestamp.split('T')[0]))].sort();
      const backends = [...new Set(filteredResults.map(r => r.backend))];

      const datasets = backends.map(backend => {
        const parallelData = dates.map(date => {
          const dayResults = filteredResults.filter(r => 
            r.backend === backend && r.timestamp.startsWith(date) && r.parallel === true
          );
          if (dayResults.length === 0) return null;
          return Math.min(...dayResults.map(r => r.mean_ns));
        });

        const sequentialData = dates.map(date => {
          const dayResults = filteredResults.filter(r => 
            r.backend === backend && r.timestamp.startsWith(date) && r.parallel === false
          );
          if (dayResults.length === 0) return null;
          return Math.min(...dayResults.map(r => r.mean_ns));
        });

        return [
          {
            label: `${backend} (Parallel)`,
            data: parallelData,
            borderColor: getColor(backend),
            backgroundColor: getColor(backend, 0.1),
            tension: 0.1,
            fill: false,
            borderDash: [5, 5]
          },
          {
            label: `${backend} (Sequential)`,
            data: sequentialData,
            borderColor: getColor(backend),
            backgroundColor: getColor(backend, 0.1),
            tension: 0.1,
            fill: false
          }
        ];
      }).flat();

      charts.parallel = new Chart(ctx, {
        type: 'line',
        data: { labels: dates, datasets },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: `${test}: Parallel vs Sequential` },
            legend: { position: 'top' }
          },
          scales: {
            y: {
              type: 'logarithmic',
              title: { display: true, text: 'Nanoseconds (log scale)' }
            }
          }
        }
      });
    }

    function createTrendsChart(results) {
      const ctx = document.getElementById('chartTrends').getContext('2d');
      
      if (charts.trends) {
        charts.trends.destroy();
      }

      const test = document.getElementById('test-select').value;
      const filteredResults = results.filter(r => r.test === test);
      
      const dates = [...new Set(filteredResults.map(r => r.timestamp.split('T')[0]))].sort();
      const backends = [...new Set(filteredResults.map(r => r.backend))];

      // Calculate speedup ratios (best performance per day)
      const datasets = backends.map(backend => {
        const data = dates.map(date => {
          const dayResults = filteredResults.filter(r => 
            r.backend === backend && r.timestamp.startsWith(date)
          );
          if (dayResults.length === 0) return null;
          
          const bestTime = Math.min(...dayResults.map(r => r.mean_ns));
          const allDayResults = filteredResults.filter(r => r.timestamp.startsWith(date));
          const slowestTime = Math.max(...allDayResults.map(r => r.mean_ns));
          
          return slowestTime / bestTime; // Speedup ratio
        });

        return {
          label: backend,
          data: data,
          borderColor: getColor(backend),
          backgroundColor: getColor(backend, 0.1),
          tension: 0.1,
          fill: false
        };
      });

      charts.trends = new Chart(ctx, {
        type: 'line',
        data: { labels: dates, datasets },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: `${test}: Relative Performance Trends` },
            legend: { position: 'top' }
          },
          scales: {
            y: {
              title: { display: true, text: 'Speedup Ratio' }
            }
          }
        }
      });
    }

    function updateCharts() {
      if (!benchmarkData) return;
      
      createBackendChart(benchmarkData.results);
      createModeChart(benchmarkData.results);
      createParallelChart(benchmarkData.results);
      createTrendsChart(benchmarkData.results);
    }

    function getColor(name, alpha = 1) {
      const colors = [
        'rgba(54, 162, 235, ' + alpha + ')',   // Blue
        'rgba(255, 99, 132, ' + alpha + ')',   // Red
        'rgba(255, 205, 86, ' + alpha + ')',   // Yellow
        'rgba(75, 192, 192, ' + alpha + ')',   // Teal
        'rgba(153, 102, 255, ' + alpha + ')',  // Purple
        'rgba(255, 159, 64, ' + alpha + ')',   // Orange
        'rgba(199, 199, 199, ' + alpha + ')',  // Grey
        'rgba(83, 102, 255, ' + alpha + ')'    // Indigo
      ];
      
      let hash = 0;
      for (let i = 0; i < name.length; i++) {
        hash = name.charCodeAt(i) + ((hash << 5) - hash);
      }
      return colors[Math.abs(hash) % colors.length];
    }

    // Load data when page loads
    loadData();
  </script>
</body>
</html>
