<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PCS Benchmarks - Polyglot Code Sampler Performance Dashboard v2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/index.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 20px;
      background: #f8f9fa;
      margin: 0;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 30px;
    }
    h1 {
      color: #2c3e50;
      margin-bottom: 10px;
      font-size: 2.5em;
    }
    .subtitle {
      color: #7f8c8d;
      margin-bottom: 30px;
      font-size: 1.1em;
    }
    .data-health {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 20px;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .data-health.healthy {
      background: #d4edda;
      border-color: #c3e6cb;
      color: #155724;
    }
    .data-health.warning {
      background: #fff3cd;
      border-color: #ffeaa7;
      color: #856404;
    }
    .data-health.error {
      background: #f8d7da;
      border-color: #f5c6cb;
      color: #721c24;
    }
    .about-panel {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      position: relative;
    }
    .about-panel h3 {
      margin-top: 0;
      color: #2c3e50;
    }
    .methods-content h4 {
      color: #34495e;
      margin-top: 20px;
      margin-bottom: 10px;
    }
    .methods-content ul {
      margin-bottom: 15px;
    }
    .methods-content li {
      margin-bottom: 5px;
    }
    .close-btn {
      position: absolute;
      top: 15px;
      right: 15px;
      background: #6c757d;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
    }
    .close-btn:hover {
      background: #5a6268;
    }
    .summary {
      background: #ecf0f1;
      padding: 20px;
      border-radius: 6px;
      margin-bottom: 30px;
    }
    .summary h3 {
      margin-top: 0;
      color: #2c3e50;
    }
    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    .summary-item {
      background: white;
      padding: 15px;
      border-radius: 4px;
      border-left: 4px solid #3498db;
    }
    .summary-item h4 {
      margin: 0 0 5px 0;
      color: #2c3e50;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .summary-item p {
      margin: 0;
      font-size: 1.2em;
      font-weight: bold;
      color: #34495e;
    }
    .controls {
      margin-bottom: 30px;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      align-items: center;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .control-group label {
      font-size: 0.9em;
      font-weight: 500;
      color: #2c3e50;
    }
    .control-group select {
      padding: 8px 12px;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      background: white;
      font-size: 0.9em;
    }
    .charts {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 30px;
      margin-bottom: 30px;
    }
    .chart-container {
      background: white;
      padding: 20px;
      border-radius: 6px;
      border: 1px solid #ecf0f1;
    }
    .chart-container h3 {
      margin-top: 0;
      color: #2c3e50;
      font-size: 1.2em;
    }
    .chart-container canvas {
      max-width: 100%;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #7f8c8d;
    }
    .error {
      background: #e74c3c;
      color: white;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 20px;
    }
    .last-updated {
      text-align: center;
      color: #95a5a6;
      font-size: 0.9em;
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #ecf0f1;
    }
    @media (max-width: 768px) {
      .container {
        padding: 15px;
      }
      .charts {
        grid-template-columns: 1fr;
      }
      .controls {
        flex-direction: column;
        align-items: stretch;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üöÄ PCS Benchmarks</h1>
    <p class="subtitle">Polyglot Code Sampler Performance Dashboard - Comparing backends over time (lower is better)</p>
    
    <div style="text-align: center; margin-bottom: 20px;">
      <button onclick="toggleAboutPanel()" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
        üìä About & Methods
      </button>
    </div>
    
    <!-- Data Health Badge -->
    <div id="data-health" class="data-health">
      <span id="health-status">üîÑ Loading...</span>
      <span id="health-details"></span>
    </div>
    
    <div id="loading" class="loading">
      <p>üìä Loading benchmark data...</p>
    </div>
    
    <div id="error" class="error" style="display: none;">
      <p>‚ùå Error loading benchmark data. Please check the console for details.</p>
    </div>
    
    <div id="content" style="display: none;">
      <div class="summary">
        <h3>üìà Summary</h3>
        <div class="summary-grid" id="summary-grid">
          <!-- Summary items will be populated by JavaScript -->
        </div>
      </div>
      
      <div class="controls">
        <div class="control-group">
          <label for="test-select">Test Case:</label>
          <select id="test-select">
            <!-- Options will be populated by JavaScript -->
          </select>
        </div>
        <div class="control-group">
          <label for="backend-select">Backend:</label>
          <select id="backend-select">
            <!-- Options will be populated by JavaScript -->
          </select>
        </div>
        <div class="control-group">
          <label for="mode-select">Mode:</label>
          <select id="mode-select">
            <!-- Options will be populated by JavaScript -->
          </select>
        </div>
        <div class="control-group">
          <label for="baseline-select">Baseline (for ratios):</label>
          <select id="baseline-select">
            <option value="">No baseline</option>
            <!-- Options will be populated by JavaScript -->
          </select>
        </div>
      </div>
      
      <!-- About & Methods Panel -->
    <div class="about-panel" id="about-panel" style="display: none;">
      <h3>üìä About & Methods</h3>
      <div class="methods-content">
        <h4>üéØ Regression Detection</h4>
        <ul>
          <li><strong>Per-Backend Thresholds:</strong> Julia 12%, Rust 8%, Go 15%, TypeScript 10%, C# 10%</li>
          <li><strong>Grace Period:</strong> 3 days for new tests to prevent false alarms</li>
          <li><strong>Method:</strong> 7-day rolling median comparison</li>
        </ul>
        
        <h4>üìà Data Quality</h4>
        <ul>
          <li><strong>Outlier Filtering:</strong> >3œÉ removal using z-score method</li>
          <li><strong>Schema Validation:</strong> Forward-compatible data validation</li>
          <li><strong>Best-of-k:</strong> Run k=5 times, record minimum for reduced noise</li>
        </ul>
        
        <h4>üîç K-Anomaly Detection</h4>
        <ul>
          <li><strong>Purpose:</strong> Detect infrastructure issues (runner problems, toolchain changes)</li>
          <li><strong>Threshold:</strong> 80% of backends showing simultaneous regressions</li>
          <li><strong>Action:</strong> Check CI runner logs and toolchain versions</li>
        </ul>
        
        <h4>üìä Dashboard Features</h4>
        <ul>
          <li><strong>Ratio Overlays:</strong> Compare backends relative to baseline</li>
          <li><strong>Data Health:</strong> Real-time freshness and diversity monitoring</li>
          <li><strong>Interactive Filters:</strong> Test, backend, mode, and baseline selection</li>
        </ul>
      </div>
      <button onclick="toggleAboutPanel()" class="close-btn">Close</button>
    </div>
    
    <div class="charts">
        <div class="chart-container">
          <h3>Performance by Backend</h3>
          <canvas id="chartByBackend"></canvas>
        </div>
        <div class="chart-container">
          <h3>Performance by Mode</h3>
          <canvas id="chartByMode"></canvas>
        </div>
        <div class="chart-container">
          <h3>Parallel vs Sequential</h3>
          <canvas id="chartParallel"></canvas>
        </div>
        <div class="chart-container">
          <h3>Cross-Backend Ratios</h3>
          <canvas id="chartRatios"></canvas>
        </div>
        <div class="chart-container">
          <h3>Performance Trends</h3>
          <canvas id="chartTrends"></canvas>
        </div>
        <div class="chart-container">
          <h3>Speedup Analysis</h3>
          <canvas id="chartSpeedup"></canvas>
        </div>
      </div>
      
      <div class="last-updated" id="last-updated">
        <!-- Last updated time will be populated by JavaScript -->
      </div>
    </div>
  </div>

  <script>
    let benchmarkData = null;
    let charts = {};

    function ratio(seriesA, seriesB) {
      return seriesA.map((v, i) => (v && seriesB[i]) ? v / seriesB[i] : null);
    }

    function toggleAboutPanel() {
      const panel = document.getElementById('about-panel');
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
      } else {
        panel.style.display = 'none';
      }
    }

    function updateDataHealth(data) {
      const healthDiv = document.getElementById('data-health');
      const statusSpan = document.getElementById('health-status');
      const detailsSpan = document.getElementById('health-details');
      
      if (!data || data.length === 0) {
        healthDiv.className = 'data-health error';
        statusSpan.textContent = '‚ùå No Data';
        detailsSpan.textContent = 'No benchmark data available';
        return;
      }
      
      // Check data freshness (last 7 days)
      const now = new Date();
      const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      
      const latestTimestamp = Math.max(...data.map(d => new Date(d.timestamp).getTime()));
      const latestDate = new Date(latestTimestamp);
      
      const daysSinceLatest = (now - latestDate) / (1000 * 60 * 60 * 24);
      
      // Check data diversity
      const backends = new Set(data.map(d => d.backend));
      const tests = new Set(data.map(d => d.test));
      
      let healthClass = 'data-health healthy';
      let status = '‚úÖ Healthy';
      let details = `${data.length} records ‚Ä¢ ${backends.size} backends ‚Ä¢ ${tests.size} tests`;
      
      if (daysSinceLatest > 7) {
        healthClass = 'data-health warning';
        status = '‚ö†Ô∏è Stale Data';
        details += ` ‚Ä¢ Last update: ${Math.round(daysSinceLatest)} days ago`;
      } else if (backends.size < 3) {
        healthClass = 'data-health warning';
        status = '‚ö†Ô∏è Limited Data';
        details += ' ‚Ä¢ Few backends available';
      } else if (data.length < 10) {
        healthClass = 'data-health warning';
        status = '‚ö†Ô∏è Low Volume';
        details += ' ‚Ä¢ Limited benchmark results';
      }
      
      healthDiv.className = healthClass;
      statusSpan.textContent = status;
      detailsSpan.textContent = details;
    }

    async function loadData() {
      try {
        const response = await fetch('./benchmarks.json?v=' + Date.now(), {cache: 'no-store'});
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const rawData = await response.json();
        
        // Handle both old format (object with results) and new format (array)
        if (rawData && typeof rawData === 'object' && rawData.results) {
          benchmarkData = rawData.results;
        } else if (Array.isArray(rawData)) {
          benchmarkData = rawData;
        } else {
          throw new Error('Invalid data format: expected array of benchmark results or object with results key');
        }
        
        if (!benchmarkData || !Array.isArray(benchmarkData)) {
          throw new Error('No valid benchmark data found');
        }
        
                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';
                
                updateDataHealth(benchmarkData);
                initializeDashboard();
      } catch (error) {
        console.error('Error loading benchmark data:', error);
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'block';
      }
    }

    function initializeDashboard() {
      const { summary, results } = benchmarkData;
      
      // Update summary
      updateSummary(summary);
      
      // Populate controls
      populateControls(results);
      
      // Create charts
      createCharts(results);
      
      // Update last updated time
      document.getElementById('last-updated').textContent = 
        `Last updated: ${new Date(summary.last_updated).toLocaleString()}`;
    }

    function updateSummary(summary) {
      const grid = document.getElementById('summary-grid');
      grid.innerHTML = `
        <div class="summary-item">
          <h4>Total Results</h4>
          <p>${summary.total_results.toLocaleString()}</p>
        </div>
        <div class="summary-item">
          <h4>Backends</h4>
          <p>${summary.backends.length}</p>
        </div>
        <div class="summary-item">
          <h4>Test Cases</h4>
          <p>${summary.tests.length}</p>
        </div>
        <div class="summary-item">
          <h4>Date Range</h4>
          <p>${summary.date_range.start} to ${summary.date_range.end}</p>
        </div>
      `;
    }

    function populateControls(results) {
      const tests = [...new Set(results.map(r => r.test))].sort();
      const backends = [...new Set(results.map(r => r.backend))].sort();
      const modes = [...new Set(results.map(r => r.mode))].sort();

      // Populate test select
      const testSelect = document.getElementById('test-select');
      testSelect.innerHTML = tests.map(test => 
        `<option value="${test}">${test}</option>`
      ).join('');

      // Populate backend select
      const backendSelect = document.getElementById('backend-select');
      backendSelect.innerHTML = backends.map(backend => 
        `<option value="${backend}">${backend}</option>`
      ).join('');

      // Populate mode select
      const modeSelect = document.getElementById('mode-select');
      modeSelect.innerHTML = modes.map(mode => 
        `<option value="${mode}">${mode}</option>`
      ).join('');

      // Add event listeners
      [testSelect, backendSelect, modeSelect].forEach(select => {
        select.addEventListener('change', () => updateCharts());
      });
    }

    function createCharts(results) {
      // Chart 1: Performance by Backend
      createBackendChart(results);
      
      // Chart 2: Performance by Mode
      createModeChart(results);
      
      // Chart 3: Parallel vs Sequential
      createParallelChart(results);
      
      // Chart 4: Cross-Backend Ratios
      createRatiosChart(results);
      
      // Chart 5: Performance Trends
      createTrendsChart(results);
      
      // Chart 6: Speedup Analysis
      createSpeedupChart(results);
    }

    function createBackendChart(results) {
      const ctx = document.getElementById('chartByBackend').getContext('2d');
      
      if (charts.backend) {
        charts.backend.destroy();
      }

      const test = document.getElementById('test-select').value;
      const filteredResults = results.filter(r => r.test === test);
      
      const dates = [...new Set(filteredResults.map(r => r.timestamp.split('T')[0]))].sort();
      const backends = [...new Set(filteredResults.map(r => r.backend))];

      const datasets = backends.map(backend => {
        const data = dates.map(date => {
          const dayResults = filteredResults.filter(r => 
            r.backend === backend && r.timestamp.startsWith(date)
          );
          if (dayResults.length === 0) return null;
          return Math.min(...dayResults.map(r => r.mean_ns));
        });

        return {
          label: backend,
          data: data,
          borderColor: getColor(backend),
          backgroundColor: getColor(backend, 0.1),
          tension: 0.1,
          fill: false
        };
      });

      charts.backend = new Chart(ctx, {
        type: 'line',
        data: { labels: dates, datasets },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: `${test}: Performance by Backend` },
            legend: { position: 'top' }
          },
          scales: {
            y: {
              type: 'logarithmic',
              title: { display: true, text: 'Nanoseconds (log scale)' }
            }
          }
        }
      });
    }

    function createModeChart(results) {
      const ctx = document.getElementById('chartByMode').getContext('2d');
      
      if (charts.mode) {
        charts.mode.destroy();
      }

      const backend = document.getElementById('backend-select').value;
      const test = document.getElementById('test-select').value;
      const filteredResults = results.filter(r => 
        r.backend === backend && r.test === test
      );
      
      const dates = [...new Set(filteredResults.map(r => r.timestamp.split('T')[0]))].sort();
      const modes = [...new Set(filteredResults.map(r => r.mode))];

      const datasets = modes.map(mode => {
        const data = dates.map(date => {
          const dayResults = filteredResults.filter(r => 
            r.mode === mode && r.timestamp.startsWith(date)
          );
          if (dayResults.length === 0) return null;
          return Math.min(...dayResults.map(r => r.mean_ns));
        });

        return {
          label: mode,
          data: data,
          borderColor: getColor(mode),
          backgroundColor: getColor(mode, 0.1),
          tension: 0.1,
          fill: false
        };
      });

      charts.mode = new Chart(ctx, {
        type: 'line',
        data: { labels: dates, datasets },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: `${backend}: ${test} by Mode` },
            legend: { position: 'top' }
          },
          scales: {
            y: {
              type: 'logarithmic',
              title: { display: true, text: 'Nanoseconds (log scale)' }
            }
          }
        }
      });
    }

    function createParallelChart(results) {
      const ctx = document.getElementById('chartParallel').getContext('2d');
      
      if (charts.parallel) {
        charts.parallel.destroy();
      }

      const test = document.getElementById('test-select').value;
      const filteredResults = results.filter(r => r.test === test);
      
      const dates = [...new Set(filteredResults.map(r => r.timestamp.split('T')[0]))].sort();
      const backends = [...new Set(filteredResults.map(r => r.backend))];

      const datasets = backends.map(backend => {
        const parallelData = dates.map(date => {
          const dayResults = filteredResults.filter(r => 
            r.backend === backend && r.timestamp.startsWith(date) && r.parallel === true
          );
          if (dayResults.length === 0) return null;
          return Math.min(...dayResults.map(r => r.mean_ns));
        });

        const sequentialData = dates.map(date => {
          const dayResults = filteredResults.filter(r => 
            r.backend === backend && r.timestamp.startsWith(date) && r.parallel === false
          );
          if (dayResults.length === 0) return null;
          return Math.min(...dayResults.map(r => r.mean_ns));
        });

        return [
          {
            label: `${backend} (Parallel)`,
            data: parallelData,
            borderColor: getColor(backend),
            backgroundColor: getColor(backend, 0.1),
            tension: 0.1,
            fill: false,
            borderDash: [5, 5]
          },
          {
            label: `${backend} (Sequential)`,
            data: sequentialData,
            borderColor: getColor(backend),
            backgroundColor: getColor(backend, 0.1),
            tension: 0.1,
            fill: false
          }
        ];
      }).flat();

      charts.parallel = new Chart(ctx, {
        type: 'line',
        data: { labels: dates, datasets },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: `${test}: Parallel vs Sequential` },
            legend: { position: 'top' }
          },
          scales: {
            y: {
              type: 'logarithmic',
              title: { display: true, text: 'Nanoseconds (log scale)' }
            }
          }
        }
      });
    }

    function createTrendsChart(results) {
      const ctx = document.getElementById('chartTrends').getContext('2d');
      
      if (charts.trends) {
        charts.trends.destroy();
      }

      const test = document.getElementById('test-select').value;
      const filteredResults = results.filter(r => r.test === test);
      
      const dates = [...new Set(filteredResults.map(r => r.timestamp.split('T')[0]))].sort();
      const backends = [...new Set(filteredResults.map(r => r.backend))];

      // Calculate speedup ratios (best performance per day)
      const datasets = backends.map(backend => {
        const data = dates.map(date => {
          const dayResults = filteredResults.filter(r => 
            r.backend === backend && r.timestamp.startsWith(date)
          );
          if (dayResults.length === 0) return null;
          
          const bestTime = Math.min(...dayResults.map(r => r.mean_ns));
          const allDayResults = filteredResults.filter(r => r.timestamp.startsWith(date));
          const slowestTime = Math.max(...allDayResults.map(r => r.mean_ns));
          
          return slowestTime / bestTime; // Speedup ratio
        });

        return {
          label: backend,
          data: data,
          borderColor: getColor(backend),
          backgroundColor: getColor(backend, 0.1),
          tension: 0.1,
          fill: false
        };
      });

      charts.trends = new Chart(ctx, {
        type: 'line',
        data: { labels: dates, datasets },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: `${test}: Relative Performance Trends` },
            legend: { position: 'top' }
          },
          scales: {
            y: {
              title: { display: true, text: 'Speedup Ratio' }
            }
          }
        }
      });
    }

    function createRatiosChart(results) {
      const ctx = document.getElementById('chartRatios').getContext('2d');
      
      if (charts.ratios) {
        charts.ratios.destroy();
      }

      const test = document.getElementById('test-select').value;
      const filteredResults = results.filter(r => r.test === test);
      
      const dates = [...new Set(filteredResults.map(r => r.timestamp.split('T')[0]))].sort();
      const backends = [...new Set(filteredResults.map(r => r.backend))];

      // Calculate ratios relative to fastest backend (Julia as baseline)
      const baseline = 'julia';
      const datasets = backends.map(backend => {
        const data = dates.map(date => {
          const baselineResults = filteredResults.filter(r => 
            r.backend === baseline && r.timestamp.startsWith(date) && !r.parallel
          );
          const backendResults = filteredResults.filter(r => 
            r.backend === backend && r.timestamp.startsWith(date) && !r.parallel
          );
          
          if (baselineResults.length === 0 || backendResults.length === 0) return null;
          
          const baselineTime = Math.min(...baselineResults.map(r => r.mean_ns));
          const backendTime = Math.min(...backendResults.map(r => r.mean_ns));
          
          return backendTime / baselineTime; // Ratio (1.0 = same speed, >1.0 = slower)
        });

        return {
          label: backend,
          data: data,
          borderColor: getColor(backend),
          backgroundColor: getColor(backend, 0.1),
          tension: 0.1,
          fill: false
        };
      });

      charts.ratios = new Chart(ctx, {
        type: 'line',
        data: { labels: dates, datasets },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: `${test}: Performance Ratios (vs ${baseline})` },
            legend: { position: 'top' }
          },
          scales: {
            y: {
              title: { display: true, text: 'Speed Ratio (1.0 = baseline)' },
              min: 0.5,
              max: 3.0
            }
          }
        }
      });
    }

    function createSpeedupChart(results) {
      const ctx = document.getElementById('chartSpeedup').getContext('2d');
      
      if (charts.speedup) {
        charts.speedup.destroy();
      }

      const test = document.getElementById('test-select').value;
      const filteredResults = results.filter(r => r.test === test);
      
      const dates = [...new Set(filteredResults.map(r => r.timestamp.split('T')[0]))].sort();
      const backends = [...new Set(filteredResults.map(r => r.backend))];

      const datasets = backends.map(backend => {
        const data = dates.map(date => {
          const sequentialResults = filteredResults.filter(r => 
            r.backend === backend && r.timestamp.startsWith(date) && !r.parallel
          );
          const parallelResults = filteredResults.filter(r => 
            r.backend === backend && r.timestamp.startsWith(date) && r.parallel
          );
          
          if (sequentialResults.length === 0 || parallelResults.length === 0) return null;
          
          const sequentialTime = Math.min(...sequentialResults.map(r => r.mean_ns));
          const parallelTime = Math.min(...parallelResults.map(r => r.mean_ns));
          
          return sequentialTime / parallelTime; // Speedup ratio
        });

        return {
          label: backend,
          data: data,
          borderColor: getColor(backend),
          backgroundColor: getColor(backend, 0.1),
          tension: 0.1,
          fill: false
        };
      });

      charts.speedup = new Chart(ctx, {
        type: 'line',
        data: { labels: dates, datasets },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: `${test}: Parallel Speedup Ratios` },
            legend: { position: 'top' }
          },
          scales: {
            y: {
              title: { display: true, text: 'Speedup Ratio (higher is better)' },
              min: 1.0
            }
          }
        }
      });
    }

    function updateCharts() {
      if (!benchmarkData) return;
      
      createBackendChart(benchmarkData.results);
      createModeChart(benchmarkData.results);
      createParallelChart(benchmarkData.results);
      createRatiosChart(benchmarkData.results);
      createTrendsChart(benchmarkData.results);
      createSpeedupChart(benchmarkData.results);
    }

    function getColor(name, alpha = 1) {
      const colors = [
        'rgba(54, 162, 235, ' + alpha + ')',   // Blue
        'rgba(255, 99, 132, ' + alpha + ')',   // Red
        'rgba(255, 205, 86, ' + alpha + ')',   // Yellow
        'rgba(75, 192, 192, ' + alpha + ')',   // Teal
        'rgba(153, 102, 255, ' + alpha + ')',  // Purple
        'rgba(255, 159, 64, ' + alpha + ')',   // Orange
        'rgba(199, 199, 199, ' + alpha + ')',  // Grey
        'rgba(83, 102, 255, ' + alpha + ')'    // Indigo
      ];
      
      let hash = 0;
      for (let i = 0; i < name.length; i++) {
        hash = name.charCodeAt(i) + ((hash << 5) - hash);
      }
      return colors[Math.abs(hash) % colors.length];
    }

    // Load data when page loads
    loadData();
  </script>

  <!-- Data Status Widget -->
  <script>
  function formatTS(ts){ try { return new Date(ts).toISOString(); } catch { return String(ts) } }
  function summarize(rows){
    if(!rows?.length) return 'No rows';
    const last = rows.slice().sort((a,b)=>new Date(a.timestamp)-new Date(b.timestamp)).at(-1);
    const bset = new Set(rows.map(r=>r.backend));
    const tset = new Set(rows.map(r=>r.test));
    return `Rows: ${rows.length} ‚Ä¢ Backends: ${[...bset].join(', ')} ‚Ä¢ Tests: ${[...tset].join(', ')} ‚Ä¢ Last: ${formatTS(last.timestamp)}`;
  }
  document.addEventListener('DOMContentLoaded', ()=>{
    const el = document.createElement('div');
    el.style.cssText = 'padding:10px;margin:8px 0;border-radius:8px;background:#f6f8fa;font:12px/1.4 system-ui, sans-serif';
    el.id = 'data-status';
    el.textContent = 'Loading data‚Ä¶';
    document.body.prepend(el);
    (async ()=>{
      try{
        const r = await fetch('./benchmarks.json?v='+Date.now(), {cache:'no-store'});
        if(!r.ok) throw new Error('HTTP '+r.status);
        const rows = await r.json();
        if(!Array.isArray(rows)) throw new Error('Not an array');
        el.textContent = summarize(rows);
      }catch(e){
        el.textContent = 'Data load error: ' + e.message;
      }
    })();
  });
  </script>
</body>
</html>
<!-- Updated Thu Sep 25 22:18:57 CDT 2025 -->
<!-- Clean deployment Thu Sep 25 22:22:27 CDT 2025 -->
<!-- Manual trigger Thu Sep 25 22:34:48 CDT 2025 -->
